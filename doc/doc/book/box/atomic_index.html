

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Transaction control &mdash; Tarantool Dev Docs  documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> Tarantool Dev Docs
          

          
            
            <img src="../../../../_static/logo_white_text.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev_guide/index.html">Contributor’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internals/source/index.html">Tarantool internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internals/source/index.html#indices-and-tables">Indices and tables</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Tarantool Dev Docs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Transaction control</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/doc/doc/book/box/atomic_index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="transaction-control">
<span id="atomic-atomic-execution"></span><h1>Transaction control<a class="headerlink" href="#transaction-control" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="transactions">
<span id="id1"></span><h1>Transactions<a class="headerlink" href="#transactions" title="Permalink to this headline">¶</a></h1>
<p>Transactions in Tarantool occur in <strong>fibers</strong> on a single <strong>thread</strong>.
That is why Tarantool has a guarantee of execution atomicity.
That requires emphasis.</p>
<div class="section" id="threads-fibers-and-yields">
<span id="atomic-threads-fibers-yields"></span><h2>Threads, fibers and yields<a class="headerlink" href="#threads-fibers-and-yields" title="Permalink to this headline">¶</a></h2>
<p>How does Tarantool process a basic operation? As an example, let’s take this
query:</p>
<div class="highlight-tarantoolsession notranslate"><div class="highlight"><pre><span></span>tarantool&gt; box.space.tester:update({3}, {{&#39;=&#39;, 2, &#39;size&#39;}, {&#39;=&#39;, 3, 0}})
</pre></div>
</div>
<p>This is equivalent to the following SQL statement for a table that stores
primary keys in <code class="docutils literal notranslate"><span class="pre">field[1]</span></code>:</p>
<div class="highlight-SQL notranslate"><div class="highlight"><pre><span></span><span class="k">UPDATE</span> <span class="n">tester</span> <span class="k">SET</span> <span class="ss">&quot;field[2]&quot;</span> <span class="o">=</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="ss">&quot;field[3]&quot;</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">WHERE</span> <span class="ss">&quot;field[1]&quot;</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>This query will be processed with three operating system <strong>threads</strong>:</p>
<ol class="arabic">
<li><p class="first">If we issue the query on a remote client, then the <strong>network thread</strong> on
the server side receives the query, parses the statement and changes it
to a server executable message which has already been checked, and which
the server instance can understand without parsing everything again.</p>
</li>
<li><p class="first">The network thread ships this message to the instance’s
<strong>transaction processor thread</strong> using a lock-free message bus.
Lua programs execute directly in the transaction processor thread,
and do not require parsing and preparation.</p>
<p>The instance’s transaction processor thread uses the primary-key index on
field[1] to find the location of the tuple. It determines that the tuple
can be updated (not much can go wrong when you’re merely changing an
unindexed field value to something shorter).</p>
</li>
<li><p class="first">The transaction processor thread sends a message to the
<a class="reference internal" href="../../dev_guide/internals_index.html#internals-wal"><span class="std std-ref">write-ahead logging (WAL) thread</span></a> to commit the
transaction. When done, the WAL thread replies with a COMMIT or ROLLBACK
result, which is returned to the client.</p>
</li>
</ol>
<p>Notice that there is only one transaction processor thread in Tarantool.
Some people are used to the idea that there can be multiple threads operating
on the database, with (say) thread #1 reading row #x, while thread #2 writes
row #y. With Tarantool, no such thing ever happens.
Only the transaction processor thread can access the database, and there is
only one transaction processor thread for each Tarantool instance.</p>
<p>Like any other Tarantool thread, the transaction processor thread can handle
many <a class="reference internal" href="../../reference/reference_lua/fiber.html#fiber-fibers"><span class="std std-ref">fibers</span></a>. A fiber is a set of computer instructions
that may contain “<strong>yield</strong>” signals. The transaction processor thread will
execute all computer instructions until a yield, then switch to execute the
instructions of a different fiber. Thus (say) the thread reads row #x for the
sake of fiber #1, then writes row #y for the sake of fiber #2.</p>
<p>Yields must happen, otherwise the transaction processor thread would stick
permanently on the same fiber. There are two types of yields:</p>
<ul class="simple">
<li><a class="reference internal" href="#atomic-implicit-yields"><span class="std std-ref">implicit yields</span></a>: every data-change operation
or network-access causes an implicit yield, and every statement that goes
through the Tarantool client causes an implicit yield.</li>
<li>explicit yields: in a Lua function, you can (and should) add
<a class="reference internal" href="../../reference/reference_lua/fiber.html#fiber-yield"><span class="std std-ref">“yield”</span></a> statements to prevent hogging. This is called
<strong>cooperative multitasking</strong>.</li>
</ul>
</div>
<div class="section" id="cooperative-multitasking">
<span id="atomic-cooperative-multitasking"></span><h2>Cooperative multitasking<a class="headerlink" href="#cooperative-multitasking" title="Permalink to this headline">¶</a></h2>
<p>Cooperative multitasking means: unless a running fiber deliberately yields
control, it is not preempted by some other fiber. But a running fiber will
deliberately yield when it encounters a “yield point”: a transaction commit,
an operating system call, or an explicit <a class="reference internal" href="../../reference/reference_lua/fiber.html#fiber-yield"><span class="std std-ref">“yield”</span></a> request.
Any system call which can block will be performed asynchronously, and any running
fiber which must wait for a system call will be preempted, so that another
ready-to-run fiber takes its place and becomes the new running fiber.</p>
<p>This model makes all programmatic locks unnecessary: cooperative multitasking
ensures that there will be no concurrency around a resource, no race conditions,
and no memory consistency issues.</p>
<p>When requests are small, for example simple UPDATE or INSERT or DELETE or SELECT,
fiber scheduling is fair: it takes only a little time to process the request,
schedule a disk write, and yield to a fiber serving the next client.</p>
<p>However, a function might perform complex computations or might be written in
such a way that yields do not occur for a long time. This can lead to
unfair scheduling, when a single client throttles the rest of the system, or to
apparent stalls in request processing. Avoiding this situation is
the responsibility of the function’s author.</p>
</div>
<div class="section" id="atomic-transactions">
<span id="id2"></span><h2>Transactions<a class="headerlink" href="#atomic-transactions" title="Permalink to this headline">¶</a></h2>
<p>In the absence of transactions, any function that contains yield points may see
changes in the database state caused by fibers that preempt.
Multi-statement transactions exist to provide <strong>isolation</strong>: each transaction
sees a consistent database state and commits all its changes atomically.
At <a class="reference internal" href="../../reference/reference_lua/box_txn_management.html#box-commit"><span class="std std-ref">commit</span></a> time, a yield happens and all transaction changes
are written to the <a class="reference internal" href="../../dev_guide/internals_index.html#internals-wal"><span class="std std-ref">write ahead log</span></a> in a single batch.
Or, if needed, transaction changes can be rolled back –
<a class="reference internal" href="../../reference/reference_lua/box_txn_management.html#box-rollback"><span class="std std-ref">completely</span></a> or to a specific
<a class="reference internal" href="../../reference/reference_lua/box_txn_management.html#box-rollback-to-savepoint"><span class="std std-ref">savepoint</span></a>.</p>
<p>To implement isolation, Tarantool uses a simple optimistic scheduler:
the first transaction to commit wins. If a concurrent active transaction
has read a value modified by a committed transaction, it is aborted.</p>
<p>The cooperative scheduler ensures that, in absence of yields,
a multi-statement transaction is not preempted and hence is never aborted.
Therefore, understanding yields is essential to writing abort-free code.</p>
<p>Sometimes while testing the transaction mechanism in Tarantool you can notice
that yielding after <code class="docutils literal notranslate"><span class="pre">box.begin()</span></code> but before any read/write operation does not
cause an abort as it should according to the description. This happens because
actually <code class="docutils literal notranslate"><span class="pre">box.begin()</span></code> does not start a transaction. It is a mark telling
Tarantool to start a transaction after some database request that follows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can’t mix storage engines in a transaction today.</p>
</div>
</div>
<div class="section" id="implicit-yields">
<span id="atomic-implicit-yields"></span><h2>Implicit yields<a class="headerlink" href="#implicit-yields" title="Permalink to this headline">¶</a></h2>
<p>The only explicit yield requests in Tarantool are <a class="reference internal" href="../../reference/reference_lua/fiber.html#fiber-sleep"><span class="std std-ref">fiber.sleep()</span></a>
and <a class="reference internal" href="../../reference/reference_lua/fiber.html#fiber-yield"><span class="std std-ref">fiber.yield()</span></a>, but many other requests “imply” yields
because Tarantool is designed to avoid blocking.</p>
<p>Database requests imply yields if and only if there is disk I/O.
For memtx, since all data is in memory, there is no disk I/O during the request.
For vinyl, since some data may not be in memory, there may be disk I/O
for a read (to fetch data from disk) or for a write (because a stall
may occur while waiting for memory to be free).
For both memtx and vinyl, since data-change requests must be recorded in the WAL,
there is normally a commit.
A commit happens automatically after every request in default “autocommit” mode,
or a commit happens at the end of a transaction in “transaction” mode,
when a user deliberately commits by calling <a class="reference internal" href="../../reference/reference_lua/box_txn_management.html#box-commit"><span class="std std-ref">box.commit()</span></a>.
Therefore for both memtx and vinyl, because there can be disk I/O,
some database operations may imply yields.</p>
<p>Many functions in modules <a class="reference internal" href="../../reference/reference_lua/fio.html#fio-section"><span class="std std-ref">fio</span></a>, <a class="reference internal" href="../../reference/reference_lua/net_box.html#net-box-module"><span class="std std-ref">net_box</span></a>,
<a class="reference internal" href="../../reference/reference_lua/console.html#console-module"><span class="std std-ref">console</span></a> and <a class="reference internal" href="../../reference/reference_lua/socket.html#socket-module"><span class="std std-ref">socket</span></a>
(the “os” and “network” requests) yield.</p>
<p>That is why executing separate commands such as <code class="docutils literal notranslate"><span class="pre">select()</span></code>, <code class="docutils literal notranslate"><span class="pre">insert()</span></code>,
<code class="docutils literal notranslate"><span class="pre">update()</span></code> in the console inside a transaction will cause an abort. This is
due to implicit yield happening after each chunk of code is executed in the console.</p>
<p><strong>Example #1</strong></p>
<ul class="simple">
<li><em>Engine = memtx</em> <a href="#id3"><span class="problematic" id="id4">|br|</span></a>
<code class="docutils literal notranslate"><span class="pre">select()</span> <span class="pre">insert()</span></code> has one yield, at the end of insertion, caused by
implicit commit; <code class="docutils literal notranslate"><span class="pre">select()</span></code> has nothing to write to the WAL and so does not
yield.</li>
<li><em>Engine = vinyl</em> <a href="#id5"><span class="problematic" id="id6">|br|</span></a>
<code class="docutils literal notranslate"><span class="pre">select()</span> <span class="pre">insert()</span></code> has between one and three yields, since <code class="docutils literal notranslate"><span class="pre">select()</span></code>
may yield if the data is not in cache, <code class="docutils literal notranslate"><span class="pre">insert()</span></code> may yield waiting for
available memory, and there is an implicit yield at commit.</li>
<li>The sequence <code class="docutils literal notranslate"><span class="pre">begin()</span> <span class="pre">insert()</span> <span class="pre">insert()</span> <span class="pre">commit()</span></code> yields only at commit
if the engine is memtx, and can yield up to 3 times if the engine is vinyl.</li>
</ul>
<p><strong>Example #2</strong></p>
<p>Assume that in space ‘tester’ there are tuples in which the third field
represents a positive dollar amount. Let’s start a transaction, withdraw
from tuple#1, deposit in tuple#2, and end the transaction, making its
effects permanent.</p>
<div class="highlight-tarantoolsession notranslate"><div class="highlight"><pre><span></span>tarantool&gt; function txn_example(from, to, amount_of_money)
         &gt;   box.begin()
         &gt;   box.space.tester:update(from, {{&#39;-&#39;, 3, amount_of_money}})
         &gt;   box.space.tester:update(to,   {{&#39;+&#39;, 3, amount_of_money}})
         &gt;   box.commit()
         &gt;   return &quot;ok&quot;
         &gt; end
---
...
tarantool&gt; txn_example({999}, {1000}, 1.00)
---
- &quot;ok&quot;
...
</pre></div>
</div>
<p>If <a class="reference internal" href="../../reference/configuration/index.html#cfg-binary-logging-snapshots-wal-mode"><span class="std std-ref">wal_mode</span></a> = ‘none’, then
implicit yielding at commit time does not take place, because there are
no writes to the WAL.</p>
<p>If a task is interactive – sending requests to the server and receiving responses –
then it involves network IO, and therefore there is an implicit yield, even if the
request that is sent to the server is not itself an implicit yield request.
Therefore, the sequence:</p>
<div class="highlight highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">select</span>
<span class="n">select</span>
<span class="n">select</span>
</pre></div>
</div>
<p>causes blocking (in memtx), if it is inside a function or Lua program being
executed on the server instance, but causes yielding (in both memtx and vinyl)
if it is done as a series of transmissions from a client, including a client which
operates via telnet, via one of the connectors, or via the
<a class="reference internal" href="../../reference/reference_rock/dbms.html#dbms-modules"><span class="std std-ref">MySQL and PostgreSQL rocks</span></a>, or via the interactive mode when
<a class="reference internal" href="../admin/server_introspection.html#admin-using-tarantool-as-a-client"><span class="std std-ref">using Tarantool as a client</span></a>.</p>
<p>After a fiber has yielded and then has regained control, it immediately issues
<a class="reference internal" href="../../reference/reference_lua/fiber.html#fiber-testcancel"><span class="std std-ref">testcancel</span></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Tarantool Core Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>