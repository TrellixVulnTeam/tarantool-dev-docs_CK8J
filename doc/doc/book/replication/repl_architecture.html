

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Replication architecture &mdash; Tarantool Dev Docs  documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> Tarantool Dev Docs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev_guide/index.html">Contributor’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internals/source/index.html">Tarantool internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internals/source/index.html#indices-and-tables">Indices and tables</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Tarantool Dev Docs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Replication architecture</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/doc/doc/book/replication/repl_architecture.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="replication-architecture">
<span id="id1"></span><h1>Replication architecture<a class="headerlink" href="#replication-architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="replication-mechanism">
<span id="id2"></span><h2>Replication mechanism<a class="headerlink" href="#replication-mechanism" title="Permalink to this headline">¶</a></h2>
<p>A pack of instances which operate on copies of the same databases make up a
<strong>replica set</strong>. Each instance in a replica set has a role, <strong>master</strong> or
<strong>replica</strong>.</p>
<p>A replica gets all updates from the master by continuously fetching and applying
its <a class="reference internal" href="../../dev_guide/internals_index.html#internals-wal"><span class="std std-ref">write ahead log (WAL)</span></a>. Each record in the WAL represents a single
Tarantool data-change request such as <a class="reference internal" href="../../reference/reference_lua/box_space_index.html#box-space-insert"><span class="std std-ref">INSERT</span></a>,
<a class="reference internal" href="../../reference/reference_lua/box_space_index.html#box-space-update"><span class="std std-ref">UPDATE</span></a> or <a class="reference internal" href="../../reference/reference_lua/box_space_index.html#box-space-delete"><span class="std std-ref">DELETE</span></a>, and is assigned
a monotonically growing log sequence number (<strong>LSN</strong>). In essence, Tarantool
replication is <strong>row-based</strong>: each data-change request is fully deterministic
and operates on a single <a class="reference internal" href="../box/data_model.html#index-box-tuple"><span class="std std-ref">tuple</span></a>. However, unlike a classical row-based log, which
contains entire copies of the changed rows, Tarantool’s WAL contains copies of the requests.
For example, for UPDATE requests, Tarantool only stores the primary key of the row and
the update operations, to save space.</p>
<p>Invocations of <strong>stored programs</strong> are not written to the WAL. Instead, records
of the actual <strong>data-change requests, performed by the Lua code</strong>, are
written to the WAL. This ensures that possible non-determinism of Lua does not
cause replication to go out of sync.</p>
<p>Data definition operations on <strong>temporary spaces</strong>, such as creating/dropping, adding
indexes, truncating, etc., are written to the WAL, since information about
temporary spaces is stored in non-temporary
system spaces, such as <a class="reference internal" href="../../reference/reference_lua/box_space_index.html#box-space-space"><span class="std std-ref">box.space._space</span></a>. Data change
operations on temporary spaces are not written to the WAL and are not replicated.</p>
<p id="replication-local">Data change operations on <strong>replication-local</strong> spaces
(spaces <a class="reference internal" href="../../reference/reference_lua/box_schema.html#box-schema-space-create"><span class="std std-ref">created</span></a> with <code class="docutils literal notranslate"><span class="pre">is_local</span> <span class="pre">=</span> <span class="pre">true</span></code>)
are written to the WAL but are not replicated.</p>
<p>To create a valid initial state, to which WAL changes can be applied, every
instance of a replica set requires a start set of
<a class="reference internal" href="../box/data_model.html#index-box-persistence"><span class="std std-ref">checkpoint files</span></a>, such as .snap files for memtx
and .run files for vinyl. A replica joining an existing replica set, chooses an
existing master and automatically downloads the initial state from it. This is
called an <strong>initial join</strong>.</p>
<p>When an entire replica set is bootstrapped for the first time, there is no
master which could provide the initial checkpoint. In such a case, replicas
connect to each other and elect a master, which then creates the starting set of
checkpoint files, and distributes it to all the other replicas. This is called
an <strong>automatic bootstrap</strong> of a replica set.</p>
<p>When a replica contacts a master (there can be many masters) for the first time,
it becomes part of a replica set. On subsequent occasions, it should always
contact a master in the same replica set. Once connected to the master, the
replica requests all changes that happened after the latest local LSN (there
can be many LSNs – each master has its own LSN).</p>
<p>Each replica set is identified by a globally unique identifier, called the
<strong>replica set UUID</strong>. The identifier is created by the master which creates the
very first checkpoint, and is part of the checkpoint file. It is stored in
system space <a class="reference internal" href="../../reference/reference_lua/box_space_index.html#box-space-schema"><span class="std std-ref">box.space._schema</span></a>. For example:</p>
<div class="highlight-tarantoolsession notranslate"><div class="highlight"><pre><span></span>tarantool&gt; box.space._schema:select{&#39;cluster&#39;}
---
- - [&#39;cluster&#39;, &#39;6308acb9-9788-42fa-8101-2e0cb9d3c9a0&#39;]
...
</pre></div>
</div>
<p id="replication-replica-id">Additionally, each instance in a replica set is assigned its own UUID, when it
joins the replica set. It is called an <strong>instance UUID</strong> and is a globally unique
identifier. The instance UUID is checked to ensure that instances do not join a different
replica set, e.g. because of a configuration error. A unique instance identifier
is also necessary to apply rows originating from different masters only once,
that is, to implement multi-master replication. This is why each row in the write
ahead log, in addition to its log sequence number, stores the instance identifier
of the instance on which it was created. But using a UUID as such an identifier
would take too much space in the write ahead log, thus a shorter integer number
is assigned to the instance when it joins a replica set. This number is then
used to refer to the instance in the write ahead log. It is called
<strong>instance id</strong>. All identifiers are stored in system space
<a class="reference internal" href="../../reference/reference_lua/box_space_index.html#box-space-cluster"><span class="std std-ref">box.space._cluster</span></a>. For example:</p>
<div class="highlight-tarantoolsession notranslate"><div class="highlight"><pre><span></span>tarantool&gt; box.space._cluster:select{}
---
- - [1, &#39;88580b5c-4474-43ab-bd2b-2409a9af80d2&#39;]
...
</pre></div>
</div>
<p>Here the instance ID is <code class="docutils literal notranslate"><span class="pre">1</span></code> (unique within the replica set), and the instance
UUID is <code class="docutils literal notranslate"><span class="pre">88580b5c-4474-43ab-bd2b-2409a9af80d2</span></code> (globally unique).</p>
<p>Using instance IDs is also handy for tracking the state of the entire
replica set. For example, <a class="reference internal" href="../../reference/reference_lua/box_introspection.html#box-introspection-box-info"><span class="std std-ref">box.info.vclock</span></a>
describes the state of replication in regard to each connected peer.</p>
<div class="highlight-tarantoolsession notranslate"><div class="highlight"><pre><span></span>tarantool&gt; box.info.vclock
---
- {1: 827, 2: 584}
...
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">vclock</span></code> contains log sequence numbers (827 and 584) for instances with
instance IDs 1 and 2.</p>
<p>Starting in Tarantool 1.7.7, it is possible for administrators to assign
the instance UUID and the replica set UUID values, rather than let the system
generate them – see the description of the
<a class="reference internal" href="../../reference/configuration/index.html#cfg-replication-replicaset-uuid"><span class="std std-ref">replicaset_uuid</span></a> configuration parameter.</p>
</div>
<div class="section" id="replication-setup">
<span id="id3"></span><h2>Replication setup<a class="headerlink" href="#replication-setup" title="Permalink to this headline">¶</a></h2>
<p>To enable replication, you need to specify two parameters in a <code class="docutils literal notranslate"><span class="pre">box.cfg{}</span></code>
request:</p>
<ul class="simple">
<li><a class="reference internal" href="../../reference/configuration/index.html#cfg-replication-replication"><span class="std std-ref">replication</span></a> which defines the
replication source(s), and</li>
<li><a class="reference internal" href="../../reference/configuration/index.html#cfg-basic-read-only"><span class="std std-ref">read_only</span></a> which is <code class="docutils literal notranslate"><span class="pre">true</span></code> for a
replica and <code class="docutils literal notranslate"><span class="pre">false</span></code> for a master.</li>
</ul>
<p>Both these parameters are “dynamic”. This allows a replica to become a master
and vice versa on the fly with the help of a <code class="docutils literal notranslate"><span class="pre">box.cfg{}</span></code> request.</p>
<p>Later we will give a detailed example of
<a class="reference internal" href="repl_bootstrap.html#replication-bootstrap"><span class="std std-ref">bootstrapping a replica set</span></a>.</p>
</div>
<div class="section" id="replication-roles-master-and-replica">
<span id="replication-roles"></span><h2>Replication roles: master and replica<a class="headerlink" href="#replication-roles-master-and-replica" title="Permalink to this headline">¶</a></h2>
<p>The replication role (master or replica) is set by the
<a class="reference internal" href="../../reference/configuration/index.html#cfg-basic-read-only"><span class="std std-ref">read_only</span></a> configuration parameter. The recommended
role is “read_only” (replica) for all but one instance in the replica set.</p>
<p>In a master-replica configuration, every change that happens on the master will
be visible on the replicas, but not vice versa.</p>
<div align="center" class="align-center"><img alt="../../../../_images/mr-1m-2r-oneway.svg" src="../../../../_images/mr-1m-2r-oneway.svg" /></div>
<p>A simple two-instance replica set with the master on one machine and the replica
on a different machine provides two benefits:</p>
<ul class="simple">
<li><strong>failover</strong>, because if the master goes down then the replica can take over,
and</li>
<li><strong>load balancing</strong>, because clients can connect to either the master or the
replica for read requests.</li>
</ul>
<p>In a <strong>master-master</strong> configuration (also called “multi-master”), every change
that happens on either instance will be visible on the other one.</p>
<div align="center" class="align-center"><img alt="../../../../_images/mm-3m-mesh.svg" src="../../../../_images/mm-3m-mesh.svg" /></div>
<p>The failover benefit in this case is still present, and the load-balancing
benefit is enhanced, because any instance can handle both read and write
requests. Meanwhile, for multi-master configurations, it is necessary to
understand the <strong>replication guarantees</strong> provided by the asynchronous protocol
that Tarantool implements.</p>
<p>Tarantool multi-master replication guarantees that each change on each master is
propagated to all instances and is applied only once. Changes from the same
instance are applied in the same order as on the originating instance. Changes
from different instances, however, can be mixed and applied in a different order on
different instances. This may lead to replication going out of sync in certain
cases.</p>
<p>For example, assuming the database is only appended to (i.e. it contains only
insertions), a multi-master configuration is safe. If there are also
deletions, but it is not mission critical that deletion happens in the same
order on all replicas (e.g. the DELETE is used to prune expired data),
a master-master configuration is also safe.</p>
<p>UPDATE operations, however, can easily go out of sync. For example, assignment
and increment are not commutative, and may yield different results if applied
in different order on different instances.</p>
<p>More generally, it is only safe to use Tarantool master-master replication if
all database changes are <strong>commutative</strong>: the end result does not depend on the
order in which the changes are applied. You can start learning more about
conflict-free replicated data types
<a class="reference external" href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">here</a>.</p>
</div>
<div class="section" id="replication-topologies-cascade-ring-and-full-mesh">
<span id="replication-topologies"></span><h2>Replication topologies: cascade, ring and full mesh<a class="headerlink" href="#replication-topologies-cascade-ring-and-full-mesh" title="Permalink to this headline">¶</a></h2>
<p>Replication topology is set by the <a class="reference internal" href="../../reference/configuration/index.html#cfg-replication-replication"><span class="std std-ref">replication</span></a>
configuration parameter. The recommended topology is a <strong>full mesh</strong>, because it
makes potential failover easy.</p>
<p>Some database products offer <strong>cascading replication</strong> topologies: creating a
replica on a replica. Tarantool does not recommend such setup.</p>
<div align="center" class="align-center"><img alt="../../../../_images/no-cascade.svg" src="../../../../_images/no-cascade.svg" /></div>
<p>The problem with a cascading replica set is that some instances have no
connection to other instances and may not receive changes from them. One
essential change that must be propagated across all instances in a replica set
is an entry in <code class="docutils literal notranslate"><span class="pre">box.space._cluster</span></code> system space with the replica set UUID.
Without knowing the replica set UUID, a master refuses to accept connections from
such instances when replication topology changes. Here is how this can happen:</p>
<div align="center" class="align-center"><img alt="../../../../_images/cascade-problem-1.svg" src="../../../../_images/cascade-problem-1.svg" /></div>
<p>We have a chain of three instances. Instance #1 contains entries for instances
#1 and #2 in its <code class="docutils literal notranslate"><span class="pre">_cluster</span></code> space. Instances #2 and #3 contain entries for
instances #1, #2 and #3 in their <code class="docutils literal notranslate"><span class="pre">_cluster</span></code> spaces.</p>
<div align="center" class="align-center"><img alt="../../../../_images/cascade-problem-2.svg" src="../../../../_images/cascade-problem-2.svg" /></div>
<p>Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as its
new master, but the master refuses the connection since it has no entry for
instance #3.</p>
<p><strong>Ring replication</strong> topology is, however, supported:</p>
<div align="center" class="align-center"><img alt="../../../../_images/cascade-to-ring.svg" src="../../../../_images/cascade-to-ring.svg" /></div>
<p>So, if you need a cascading topology, you may first create a ring to ensure all
instances know each other’s UUID, and then disconnect the chain in the place you
desire.</p>
<p>A stock recommendation for a master-master replication topology, however, is a
<strong>full mesh</strong>:</p>
<div align="center" class="align-center"><img alt="../../../../_images/mm-3m-mesh.svg" src="../../../../_images/mm-3m-mesh.svg" /></div>
<p>You then can decide where to locate instances of the mesh – within the same
data center, or spread across a few data centers. Tarantool will automatically
ensure that each row is applied only once on each instance. To remove a degraded
instance from a mesh, simply change the <code class="docutils literal notranslate"><span class="pre">replication</span></code> configuration parameter.</p>
<p>This ensures full cluster availability in case of a local failure, e.g. one of
the instances failing in one of the data centers, as well as in case of an
entire data center failure.</p>
<p>The maximal number of replicas in a mesh is 32.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Tarantool Core Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>