

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Architecture &mdash; Tarantool Dev Docs  documentation</title>
  

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home" alt="Documentation Home"> Tarantool Dev Docs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev_guide/index.html">Contributor’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../internals/source/index.html">Tarantool internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../internals/source/index.html#indices-and-tables">Indices and tables</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Tarantool Dev Docs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Architecture</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../../_sources/doc/doc/reference/reference_rock/vshard/vshard_architecture.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="architecture">
<span id="vshard-architecture"></span><h1>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<span id="vshard-architecture-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Consider a distributed Tarantool cluster that consists of subclusters called
<strong>shards</strong>, each storing some part of data. Each shard, in its turn, constitutes
a <strong>replica set</strong> consisting of several <strong>replicas</strong>, one of which serves as a master
node that processes all read and write requests.</p>
<p>The whole dataset is logically partitioned into a predefined number of <a class="reference internal" href="#vshard-vbuckets"><span class="std std-ref">virtual
buckets</span></a> (further just <strong>buckets</strong>), each assigned a unique number
ranging from 1 to N, where N is the total number of buckets.
The number of buckets is specifically chosen
to be several orders of magnitude larger than the potential number of cluster
nodes, even given future cluster scaling. For example, with M projected nodes
the dataset may be split into 100 * M or even 1,000 * M buckets. Care should
be taken when picking the number of buckets: if too large, it may require extra
memory for storing the routing information; if too small, it may decrease
the granularity of rebalancing.</p>
<p>Each shard stores a unique subset of buckets, which means that a bucket cannot
belong to several shards at once, as illustrated below:</p>
<div align="center" class="align-center"><img alt="../../../../../_images/bucket.svg" src="../../../../../_images/bucket.svg" /></div>
<p>This shard-to-bucket mapping is stored in a table in one of Tarantool’s system
spaces, with each shard holding only a specific part of the mapping that covers
those buckets that were assigned to this shard.</p>
<p>Apart from the mapping table, the <strong>bucket id</strong> is also stored in a special field of
every tuple of every table participating in sharding.</p>
<p>Once a shard receives any request (except for SELECT) from an
application, this shard checks the bucket id specified in the request
against the table of bucket ids that belong to a given node. If the
specified bucket id is invalid, the request gets terminated with the
following error: “wrong bucket”. Otherwise the request is executed, and
all the data created in the process is assigned the bucket id specified
in the request. Note that the request should only modify the data that
has the same bucket id as the request itself.</p>
<p>Storing bucket ids both in the data itself and the mapping table ensures data
consistency regardless of the application logic and makes rebalancing
transparent for the application. Storing the mapping table in a system space
ensures sharding is performed consistently in case of a failover, as all the
replicas in a shard share a common table state.</p>
<div class="section" id="virtual-buckets">
<span id="vshard-vbuckets"></span><h3>Virtual buckets<a class="headerlink" href="#virtual-buckets" title="Permalink to this headline">¶</a></h3>
<p>The sharded dataset is partitioned into a large number of abstract nodes called
<strong>virtual buckets</strong> (further just <strong>buckets</strong>).</p>
<p>The dataset is partitioned using the sharding key (or <strong>bucket id</strong>, in Tarantool
terminology). Bucket id is a number from 1 to N, where N is the total number of
buckets.</p>
<div align="center" class="align-center"><img alt="../../../../../_images/buckets.svg" src="../../../../../_images/buckets.svg" /></div>
<p>Each replica set stores a unique subset of buckets. One bucket cannot belong to
multiple replica sets at a time.</p>
<p>The total number of buckets is determined by the administrator who sets up the
initial cluster configuration.</p>
<p>Every space you plan to shard must have a numeric field containing bucket id-s.
This field must comply with the following requirements:</p>
<ul class="simple">
<li>The field’s data type can be: unsigned, number or integer.</li>
<li>The field must be not nullable.</li>
<li>The field must be indexed by the <a class="reference internal" href="vshard_ref.html#cfg-basic-shard-index"><span class="std std-ref">shard_index</span></a>.
The default name for this index is <code class="docutils literal notranslate"><span class="pre">bucket_id</span></code>.</li>
</ul>
<p>See the <a class="reference internal" href="vshard_admin.html#vshard-define-spaces"><span class="std std-ref">configuration example</span></a>.</p>
</div>
</div>
<div class="section" id="structure">
<span id="vshard-structure"></span><h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<p>A sharded cluster in Tarantool consists of:</p>
<ul class="simple">
<li>storages,</li>
<li>routers,</li>
<li>and a rebalancer.</li>
</ul>
<div align="center" class="align-center"><img alt="../../../../../_images/schema.svg" src="../../../../../_images/schema.svg" /></div>
<div class="section" id="storage">
<span id="vshard-storage"></span><h3>Storage<a class="headerlink" href="#storage" title="Permalink to this headline">¶</a></h3>
<p><strong>Storage</strong> is a node storing a subset of the dataset. Multiple replicated (for
redundancy) storages comprise a <strong>replica set</strong> (also called <strong>shard</strong>).</p>
<p>Each storage in a replica set has a role, <strong>master</strong> or <strong>replica</strong>. A master
processes read and write requests. A replica processes read requests but cannot
process write requests.</p>
<div align="center" class="align-center"><img alt="../../../../../_images/master_replica.svg" src="../../../../../_images/master_replica.svg" /></div>
</div>
<div class="section" id="router">
<span id="vshard-router"></span><h3>Router<a class="headerlink" href="#router" title="Permalink to this headline">¶</a></h3>
<p><strong>Router</strong> is a standalone software component that routes read and write requests
from the client application to shards.</p>
<p>All requests from the application come to the sharded cluster through a <code class="docutils literal notranslate"><span class="pre">router</span></code>.
The <code class="docutils literal notranslate"><span class="pre">router</span></code> keeps the topology of a sharded cluster transparent for the application,
thus keeping the application unaware of:</p>
<ul class="simple">
<li>the number and location of shards,</li>
<li>data rebalancing process,</li>
<li>the fact and the process of a failover that occurred after a replica’s failure.</li>
</ul>
<p>A router can also calculate a bucket id on its own provided that the application
clearly defines rules for calculating a bucket id based on the request data.
To do it, a router needs to be aware of the data schema.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">router</span></code> does not have a persistent state, nor does it store the cluster topology
or balance the data. The <code class="docutils literal notranslate"><span class="pre">router</span></code> is a standalone software component that can run
in the storage layer or application layer depending on the application features.</p>
<p>A router maintains a constant pool of connections to all the storages that is
created at startup. Creating it this way helps avoid configuration errors. Once
a pool is created, a router caches the current state of the <code class="docutils literal notranslate"><span class="pre">_vbucket</span></code> table to
speed up the routing. In case a bucket id is moved to another storage as
a result of data rebalancing, or one of the shards fails over to a replica,
a router updates the routing table in a way that’s transparent for the application.</p>
<p>Sharding is not integrated into any centralized configuration storage system.
It is assumed that the application itself handles all the interactions with such
systems and passes sharding parameters. That said, the configuration can be
changed dynamically - for example, when adding or deleting one or several shards:</p>
<ol class="arabic simple">
<li>To add a new shard to the cluster, a system administrator first changes the
configuration of all the routers and then the configuration of all the storages.</li>
<li>The new shard becomes available to the storage layer for rebalancing.</li>
<li>As a result of rebalancing, one of the vbuckets is moved to the new shard.</li>
<li>When trying to access the vbucket, a router receives a special error code
that specifies the new vbucket location.</li>
</ol>
<div class="section" id="crud-create-replace-update-delete-operations">
<h4>CRUD (create, replace, update, delete) operations<a class="headerlink" href="#crud-create-replace-update-delete-operations" title="Permalink to this headline">¶</a></h4>
<p>CRUD operations can be:</p>
<ul class="simple">
<li>executed in a stored procedure inside a storage, or</li>
<li>initialized by the application.</li>
</ul>
<p>In any case, the application must include the operation bucket id in a request.
When executing an INSERT request, the operation bucket id is stored in a newly
created tuple. In other cases, it is checked if the specified operation
bucket id matches the bucket id of a tuple being modified.</p>
</div>
<div class="section" id="select-requests">
<h4>SELECT requests<a class="headerlink" href="#select-requests" title="Permalink to this headline">¶</a></h4>
<p>Since a storage is not aware of the mapping between a bucket id and a primary
key, all the SELECT requests executed in stored procedures inside a storage are
only executed locally. Those SELECT requests that were initialized by the
application are forwarded to a router. Then, if the application has passed
a bucket id, a router uses it for shard calculation.</p>
</div>
<div class="section" id="calling-stored-procedures">
<h4>Calling stored procedures<a class="headerlink" href="#calling-stored-procedures" title="Permalink to this headline">¶</a></h4>
<p>There are several ways of calling stored procedures in cluster replica sets.
Stored procedures can be called:</p>
<ul class="simple">
<li>on a specific vbucket located in a replica set (in this case, it is necessary
to differentiate between read and write procedures, as write procedures are not
applicable to vbuckets that are being migrated), or</li>
<li>without specifying any particular vbucket.</li>
</ul>
<p>All the routing validity checks performed for sharded DML operations hold true
for vbucket-bound stored procedures as well.</p>
</div>
</div>
<div class="section" id="rebalancer">
<span id="vshard-rebalancer"></span><h3>Rebalancer<a class="headerlink" href="#rebalancer" title="Permalink to this headline">¶</a></h3>
<p><strong>Rebalancer</strong> is a background rebalancing process that ensures an even
distribution of buckets across the shards. During rebalancing, buckets are being
migrated among replica sets.</p>
<p>The rebalancer “wakes up” periodically and redistributes data from the most
loaded nodes to less loaded nodes. Rebalancing starts if the <strong>disbalance threshold</strong>
of a replica set exceeds a disbalance threshold specified in the configuration.</p>
<p>The disbalance threshold is calculated as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100
</pre></div>
</div>
</div>
</div>
<div class="section" id="migration-of-buckets">
<span id="vshard-migrate-buckets"></span><h2>Migration of buckets<a class="headerlink" href="#migration-of-buckets" title="Permalink to this headline">¶</a></h2>
<p>A replica set from which the bucket is being migrated is called a <strong>source</strong> ; a
target replica set to which the bucket is being migrated is called a <strong>destination</strong>.</p>
<p>A <strong>replica set lock</strong> makes a replica set invisible to the rebalancer. A locked
replica set can neither receive new buckets nor migrate its own buckets.</p>
<p>While a bucket is being migrated, it can have different states:</p>
<ul class="simple">
<li>ACTIVE – the bucket is available for read and write requests.</li>
<li>PINNED – the bucket is locked for migrating to another replica set. Otherwise
pinned buckets are similar to buckets in the ACTIVE state.</li>
<li>SENDING – the bucket is currently being copied to the destination replica set;
read requests to the source replica set are still processed.</li>
<li>RECEIVING – the bucket is currently being filled; all requests to it are rejected.</li>
<li>SENT – the bucket was migrated to the destination replica set. The <cite>router</cite>
uses the SENT state to calculate the new location of the bucket. A bucket in
the SENT state goes to the GARBAGE state automatically after BUCKET_SENT_GARBAGE_DELAY
seconds, which by default is <a class="reference internal" href="vshard_ref.html#cfg-basic-collect-bucket-garbage-interval"><span class="std std-ref">0.5 seconds</span></a>.</li>
<li>GARBAGE – the bucket was already migrated to the destination replica set during
rebalancing; or the bucket was initially in the RECEIVING state, but some error
occurred during the migration.</li>
</ul>
<p>Buckets in the GARBAGE state are deleted by the garbage collector.</p>
<div align="center" class="align-center"><img alt="../../../../../_images/states.svg" src="../../../../../_images/states.svg" /></div>
<p>Migration is performed as follows:</p>
<ol class="arabic simple">
<li>At the destination replica set, a new bucket is created and assigned the RECEIVING
state, the data copying starts, and the bucket rejects all requests.</li>
<li>The source bucket in the source replica set is assigned the SENDING state, and
the bucket continues to process read requests.</li>
<li>Once the data is copied, the bucket on the source replica set is assigned the SENT
and it starts rejecting all requests.</li>
<li>The bucket on the destination replica set is assigned the ACTIVE state and starts
accepting all requests.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a specific error <code class="docutils literal notranslate"><span class="pre">vshard.error.code.TRANSFER_IS_IN_PROGRESS</span></code> that
returns in case a request tries to perform an action not applicable to a bucket
which is being relocated. You need to retry the request in this case.</p>
</div>
<div class="section" id="the-bucket-system-space">
<span id="vshard-bucket-space"></span><h3>The <cite>_bucket</cite> system space<a class="headerlink" href="#the-bucket-system-space" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">_bucket</span></code> system space of each replica set stores the ids of buckets present
in the replica set. The space contains the following fields:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">bucket</span></code> – bucket id</li>
<li><code class="docutils literal notranslate"><span class="pre">status</span></code> – state of the bucket</li>
<li><code class="docutils literal notranslate"><span class="pre">destination</span></code> – UUID of the destination replica set</li>
</ul>
<p>An example of <code class="docutils literal notranslate"><span class="pre">_bucket.select{}</span></code>:</p>
<div class="highlight-tarantoolsession notranslate"><div class="highlight"><pre><span></span>---
- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]
  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]
...
</pre></div>
</div>
<p>Once the bucket is migrated, the destination replica set identified by UUID is filled in the
table. While the bucket is still located on the source replica set, the value of
the destination replica set UUID is equal to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<div class="section" id="the-routing-table">
<span id="vshard-routing-table"></span><h3>The routing table<a class="headerlink" href="#the-routing-table" title="Permalink to this headline">¶</a></h3>
<p>А routing table on the <code class="docutils literal notranslate"><span class="pre">router</span></code> stores the map of all bucket ids to replica sets.
It ensures the consistency of sharding in case of failover.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">router</span></code> keeps a persistent pool of connections to all the storages that
are created at startup. This helps prevent configuration errors. Once the connection
pool is created, the <code class="docutils literal notranslate"><span class="pre">router</span></code> caches the current state of the routing table in order
to speed up routing. If a bucket migrated to another <code class="docutils literal notranslate"><span class="pre">storage</span></code> after rebalancing,
or a failover occurred and caused one of the shards switching to another replica,
the <code class="docutils literal notranslate"><span class="pre">discovery</span> <span class="pre">fiber</span></code> on the <code class="docutils literal notranslate"><span class="pre">router</span></code> updates the routing table automatically.</p>
<p>As the bucket id is explicitly indicated both in the data and in the mapping table
on the <code class="docutils literal notranslate"><span class="pre">router</span></code>, the data is consistent regardless of the application logic. It also
makes rebalancing transparent for the application.</p>
</div>
</div>
<div class="section" id="processing-requests">
<span id="vshard-process-requests"></span><h2>Processing requests<a class="headerlink" href="#processing-requests" title="Permalink to this headline">¶</a></h2>
<p>Requests to the database can be performed by the application or using stored
procedures. Either way, the bucket id should be explicitly specified in the request.</p>
<p>All requests are forwarded to the <code class="docutils literal notranslate"><span class="pre">router</span></code> first. The only operation supported
by the <code class="docutils literal notranslate"><span class="pre">router</span></code> is <code class="docutils literal notranslate"><span class="pre">call</span></code>. The operation is performed via the <code class="docutils literal notranslate"><span class="pre">vshard.router.call()</span></code>
function:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">vshard</span><span class="p">.</span><span class="n">router</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="o">&lt;</span><span class="n">bucket_id</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">mode</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">{</span><span class="o">&lt;</span><span class="n">argument_list</span><span class="o">&gt;</span><span class="p">},</span> <span class="p">{</span><span class="o">&lt;</span><span class="n">opts</span><span class="o">&gt;</span><span class="p">})</span>
</pre></div>
</div>
<p>Requests are processed as follows:</p>
<ol class="arabic">
<li><p class="first">The <code class="docutils literal notranslate"><span class="pre">router</span></code> uses the bucket id to search for a replica set with the
corresponding bucket in the routing table.</p>
<p>If the map of the bucket id to the replica set is not known to the <code class="docutils literal notranslate"><span class="pre">router</span></code>
(the discovery fiber hasn’t filled the table yet), the <code class="docutils literal notranslate"><span class="pre">router</span></code> makes requests
to all <code class="docutils literal notranslate"><span class="pre">storages</span></code> to find out where the bucket is located.</p>
</li>
<li><p class="first">Once the bucket is located, the shard checks:</p>
<ul class="simple">
<li>whether the bucket is stored in the <code class="docutils literal notranslate"><span class="pre">_bucket</span></code> system space of the replica set;</li>
<li>whether the bucket is ACTIVE or PINNED (for a read request, it can also be SENDING).</li>
</ul>
</li>
<li><p class="first">If all the checks succeed, the request is executed. Otherwise, it is terminated
with the error: <code class="docutils literal notranslate"><span class="pre">“wrong</span> <span class="pre">bucket”</span></code>.</p>
</li>
</ol>
</div>
<div class="section" id="glossary">
<span id="vshard-glossary"></span><h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="glossary docutils">
<dt id="term-vertical-scaling"><strong>Vertical scaling</strong></dt>
<dd>Adding more power to a single server: using a more powerful CPU, adding
more capacity to RAM, adding more storage space, etc.</dd>
<dt id="term-horizontal-scaling"><strong>Horizontal scaling</strong></dt>
<dd>Adding more servers to the pool of resources, then partitioning and
distributing a dataset across the servers.</dd>
<dt id="term-sharding"><strong>Sharding</strong></dt>
<dd>A database architecture that allows partitioning a dataset using a sharding
key and distributing a dataset across multiple servers. Sharding is a
special case of horizontal scaling.</dd>
<dt id="term-node"><strong>Node</strong></dt>
<dd>A virtual or physical server instance.</dd>
<dt id="term-cluster"><strong>Cluster</strong></dt>
<dd>A set of nodes that make up a single group.</dd>
<dt id="term-storage"><strong>Storage</strong></dt>
<dd>A node storing a subset of a dataset.</dd>
<dt id="term-replica-set"><strong>Replica set</strong></dt>
<dd>A set of storage nodes storing copies of a dataset. Each storage in a
replica set has a role, master or replica.</dd>
<dt id="term-master"><strong>Master</strong></dt>
<dd>A storage in a replica set processing read and write requests.</dd>
<dt id="term-replica"><strong>Replica</strong></dt>
<dd>A storage in a replica set processing only read requests.</dd>
<dt id="term-read-requests"><strong>Read requests</strong></dt>
<dd>Read-only requests, that is, select requests.</dd>
<dt id="term-write-requests"><strong>Write requests</strong></dt>
<dd>Data-change operations, that is create, replace, update, delete requests.</dd>
<dt id="term-buckets-virtual-buckets"><strong>Buckets (virtual buckets)</strong></dt>
<dd>The abstract virtual nodes into which the dataset is partitioned by the
sharding key (bucket id).</dd>
<dt id="term-bucket-id"><strong>Bucket id</strong></dt>
<dd>A sharding key defining which bucket belongs to which replica set.
A bucket id may be calculated from a <a class="reference internal" href="vshard_ref.html#router-api-bucket-id-strcrc32"><span class="std std-ref">hash key</span></a>.</dd>
<dt id="term-router"><strong>Router</strong></dt>
<dd>A proxy server responsible for routing requests from an application to
nodes in a cluster.</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Tarantool Core Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>